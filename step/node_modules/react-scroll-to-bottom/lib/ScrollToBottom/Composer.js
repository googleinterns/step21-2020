"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireWildcard(require("react"));

var _EventSpy = _interopRequireDefault(require("../EventSpy"));

var _FunctionContext = _interopRequireDefault(require("./FunctionContext"));

var _InternalContext = _interopRequireDefault(require("./InternalContext"));

var _SpineTo = _interopRequireDefault(require("../SpineTo"));

var _StateContext = _interopRequireDefault(require("./StateContext"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var MIN_CHECK_INTERVAL = 17; // 1 frame

var MODE_BOTTOM = 'bottom';
var MODE_TOP = 'top';
var NEAR_END_THRESHOLD = 1;
var SCROLL_DECISION_DURATION = 34; // 2 frames

function setImmediateInterval(fn, ms) {
  fn();
  return setInterval(fn, ms);
}

function computeViewState(_ref) {
  var mode = _ref.mode,
      _ref$target = _ref.target,
      offsetHeight = _ref$target.offsetHeight,
      scrollHeight = _ref$target.scrollHeight,
      scrollTop = _ref$target.scrollTop;
  var atBottom = scrollHeight - scrollTop - offsetHeight < NEAR_END_THRESHOLD;
  var atTop = scrollTop < NEAR_END_THRESHOLD;
  var atEnd = mode === MODE_TOP ? atTop : atBottom;
  var atStart = mode !== MODE_TOP ? atTop : atBottom;
  return {
    atBottom: atBottom,
    atEnd: atEnd,
    atStart: atStart,
    atTop: atTop
  };
}

function isEnd(scrollTop, mode) {
  return mode === MODE_TOP && scrollTop === 0 || mode === MODE_BOTTOM && scrollTop === '100%';
}

var Composer = function Composer(_ref2) {
  var checkInterval = _ref2.checkInterval,
      children = _ref2.children,
      debounce = _ref2.debounce,
      mode = _ref2.mode;
  mode = mode === MODE_TOP ? MODE_TOP : MODE_BOTTOM;
  var ignoreScrollEventBeforeRef = (0, _react.useRef)(0);

  var _useState = (0, _react.useState)(mode === MODE_TOP ? 0 : '100%'),
      _useState2 = _slicedToArray(_useState, 2),
      scrollTop = _useState2[0],
      setScrollTop = _useState2[1];

  var _useState3 = (0, _react.useState)(null),
      _useState4 = _slicedToArray(_useState3, 2),
      target = _useState4[0],
      setTarget = _useState4[1]; // Internal context


  var _useState5 = (0, _react.useState)(0),
      _useState6 = _slicedToArray(_useState5, 2),
      offsetHeight = _useState6[0],
      setOffsetHeight = _useState6[1];

  var _useState7 = (0, _react.useState)(0),
      _useState8 = _slicedToArray(_useState7, 2),
      scrollHeight = _useState8[0],
      setScrollHeight = _useState8[1]; // State context


  var _useState9 = (0, _react.useState)(false),
      _useState10 = _slicedToArray(_useState9, 2),
      animating = _useState10[0],
      setAnimating = _useState10[1];

  var _useState11 = (0, _react.useState)(true),
      _useState12 = _slicedToArray(_useState11, 2),
      atBottom = _useState12[0],
      setAtBottom = _useState12[1];

  var _useState13 = (0, _react.useState)(true),
      _useState14 = _slicedToArray(_useState13, 2),
      atEnd = _useState14[0],
      setAtEnd = _useState14[1];

  var _useState15 = (0, _react.useState)(true),
      _useState16 = _slicedToArray(_useState15, 2),
      atTop = _useState16[0],
      setAtTop = _useState16[1];

  var _useState17 = (0, _react.useState)(false),
      _useState18 = _slicedToArray(_useState17, 2),
      atStart = _useState18[0],
      setAtStart = _useState18[1];

  var _useState19 = (0, _react.useState)(true),
      _useState20 = _slicedToArray(_useState19, 2),
      sticky = _useState20[0],
      setSticky = _useState20[1]; // High-rate state context


  var scrollPositionObserversRef = (0, _react.useRef)([]);
  var observeScrollPosition = (0, _react.useCallback)(function (fn) {
    scrollPositionObserversRef.current.push(fn);
    target && fn({
      scrollTop: target.scrollTop
    });
    return function () {
      var scrollPositionObservers = scrollPositionObserversRef.current;
      var index = scrollPositionObservers.indexOf(fn);
      ~index && scrollPositionObservers.splice(index, 1);
    };
  }, [scrollPositionObserversRef, target]);
  var handleScrollEnd = (0, _react.useCallback)(function () {
    ignoreScrollEventBeforeRef.current = Date.now();
    setAnimating(false);
    setScrollTop(null);
  }, [ignoreScrollEventBeforeRef, setAnimating, setScrollTop]); // Function context

  var scrollTo = (0, _react.useCallback)(function (scrollTop) {
    var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        behavior = _ref3.behavior;

    if (behavior === 'auto') {
      // Stop any existing animation
      handleScrollEnd(); // Jump to the scroll position

      target.scrollTop = scrollTop === '100%' ? target.scrollHeight - target.offsetHeight : scrollTop;
    } else {
      behavior !== 'smooth' && console.warn('react-scroll-to-bottom: Please set "behavior" when calling "scrollTo". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.');
      setAnimating(true);
      setScrollTop(scrollTop);
    }
  }, [handleScrollEnd, setAnimating, setScrollTop, target]);
  var scrollToBottom = (0, _react.useCallback)(function () {
    var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        behavior = _ref4.behavior;

    behavior !== 'smooth' && console.warn('react-scroll-to-bottom: Please set "behavior" when calling "scrollToBottom". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.');
    scrollTo('100%', {
      behavior: behavior || 'smooth'
    });
  }, [scrollTo]);
  var scrollToTop = (0, _react.useCallback)(function () {
    var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        behavior = _ref5.behavior;

    behavior !== 'smooth' && console.warn('react-scroll-to-bottom: Please set "behavior" when calling "scrollToTop". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.');
    scrollTo(0, {
      behavior: behavior || 'smooth'
    });
  }, [scrollTo]);
  var scrollToEnd = (0, _react.useCallback)(function () {
    var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        behavior = _ref6.behavior;

    behavior !== 'smooth' && console.warn('react-scroll-to-bottom: Please set "behavior" when calling "scrollToEnd". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.');
    var options = {
      behavior: behavior || 'smooth'
    };
    mode === MODE_TOP ? scrollToTop(options) : scrollToBottom(options);
  }, [mode, scrollToBottom, scrollToTop]);
  var scrollToStart = (0, _react.useCallback)(function () {
    var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        behavior = _ref7.behavior;

    behavior !== 'smooth' && console.warn('react-scroll-to-bottom: Please set "behavior" when calling "scrollToStart". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.');
    var options = {
      behavior: behavior || 'smooth'
    };
    mode === MODE_TOP ? scrollToBottom(options) : scrollToTop(options);
  }, [mode, scrollToBottom, scrollToTop]);
  (0, _react.useEffect)(function () {
    if (sticky) {
      var stickyButNotAtEndSince = false;
      var timeout = setImmediateInterval(function () {
        if (sticky && target && !computeViewState({
          mode: mode,
          target: target
        }).atEnd) {
          if (!stickyButNotAtEndSince) {
            stickyButNotAtEndSince = Date.now();
          } else if (Date.now() - stickyButNotAtEndSince > SCROLL_DECISION_DURATION) {
            // Quirks: In Firefox, after user scroll down, Firefox do two things:
            //         1. Set to a new "scrollTop"
            //         2. Fire "scroll" event
            //         For what we observed, #1 is fired about 20ms before #2. There is a chance that this stickyCheckTimeout is being scheduled between 1 and 2.
            //         That means, if we just look at #1 to decide if we should scroll, we will always scroll, in oppose to the user's intention.
            // Repro: Open Firefox, set checkInterval to a lower number, and try to scroll by dragging the scroll handler. It will jump back.
            !animating && scrollToEnd({
              behavior: 'smooth'
            });
            stickyButNotAtEndSince = false;
          }
        } else {
          stickyButNotAtEndSince = false;
        }
      }, Math.max(MIN_CHECK_INTERVAL, checkInterval) || MIN_CHECK_INTERVAL);
      return function () {
        return clearInterval(timeout);
      };
    }
  }, [animating, checkInterval, mode, scrollToEnd, sticky, target]);
  var handleScroll = (0, _react.useCallback)(function (_ref8) {
    var timeStampLow = _ref8.timeStampLow;

    // Currently, there are no reliable way to check if the "scroll" event is trigger due to
    // user gesture, programmatic scrolling, or Chrome-synthesized "scroll" event to compensate size change.
    // Thus, we use our best-effort to guess if it is triggered by user gesture, and disable sticky if it is heading towards the start direction.
    if (timeStampLow <= ignoreScrollEventBeforeRef.current) {
      // Since we debounce "scroll" event, this handler might be called after spineTo.onEnd (a.k.a. artificial scrolling).
      // We should ignore debounced event fired after scrollEnd, because without skipping them, the userInitiatedScroll calculated below will not be accurate.
      // Thus, on a fast machine, adding elements super fast will lose the "stickiness".
      return;
    }

    if (target) {
      var _computeViewState = computeViewState({
        mode: mode,
        target: target
      }),
          _atBottom = _computeViewState.atBottom,
          _atEnd = _computeViewState.atEnd,
          _atStart = _computeViewState.atStart,
          _atTop = _computeViewState.atTop;

      setAtBottom(_atBottom);
      setAtEnd(_atEnd);
      setAtStart(_atStart);
      setAtTop(_atTop); // Chrome will emit "synthetic" scroll event if the container is resized or an element is added
      // We need to ignore these "synthetic" events
      // Repro: In playground, press 4-1-5-1-1 (small, add one, normal, add one, add one)
      //        Nomatter how fast or slow the sequence is being pressed, it should still stick to the bottom

      var nextOffsetHeight = target.offsetHeight,
          nextScrollHeight = target.scrollHeight;
      var offsetHeightChanged = nextOffsetHeight !== offsetHeight;
      var scrollHeightChanged = nextScrollHeight !== scrollHeight;
      offsetHeightChanged && setOffsetHeight(nextOffsetHeight);
      scrollHeightChanged && setScrollHeight(nextScrollHeight); // Sticky means:
      // - If it is scrolled programatically, we are still in sticky mode
      // - If it is scrolled by the user, then sticky means if we are at the end
      // Only update stickiness if the scroll event is not due to synthetic scroll done by Chrome

      !offsetHeightChanged && !scrollHeightChanged && setSticky( // We are sticky if we are animating to the end, or we are already at the end.
      // We can be "animating but not sticky" by calling "scrollTo(100)" where the container scrollHeight is 200px.
      animating && isEnd(scrollTop, mode) || _atEnd); // If no scrollTop is set (not in programmatic scrolling mode), we should set "animating" to false
      // "animating" is used to calculate the "sticky" property

      scrollTop === null && setAnimating(false);
      var actualScrollTop = target.scrollTop;
      scrollPositionObserversRef.current.forEach(function (observer) {
        return observer({
          scrollTop: actualScrollTop
        });
      });
    }
  }, [animating, ignoreScrollEventBeforeRef, mode, offsetHeight, scrollHeight, scrollPositionObserversRef, scrollTop, setAnimating, setAtBottom, setAtEnd, setAtStart, setAtTop, setOffsetHeight, setScrollHeight, setSticky, target]);
  var internalContext = (0, _react.useMemo)(function () {
    return {
      observeScrollPosition: observeScrollPosition,
      offsetHeight: offsetHeight,
      scrollHeight: scrollHeight,
      setTarget: setTarget
    };
  }, [observeScrollPosition, offsetHeight, scrollHeight, setTarget]);
  var animatingToEnd = animating && isEnd(scrollTop, mode);
  var stateContext = (0, _react.useMemo)(function () {
    return {
      animating: animating,
      animatingToEnd: animatingToEnd,
      atBottom: atBottom,
      atEnd: atEnd,
      atStart: atStart,
      atTop: atTop,
      mode: mode,
      sticky: sticky
    };
  }, [animating, animatingToEnd, atBottom, atEnd, atStart, atTop, mode, sticky]);
  var functionContext = (0, _react.useMemo)(function () {
    return {
      scrollTo: scrollTo,
      scrollToBottom: scrollToBottom,
      scrollToEnd: scrollToEnd,
      scrollToStart: scrollToStart,
      scrollToTop: scrollToTop
    };
  }, [scrollTo, scrollToBottom, scrollToEnd, scrollToStart, scrollToTop]);
  (0, _react.useEffect)(function () {
    // We need to update the "scrollHeight" value to latest when the user do a focus inside the box.
    //
    // This is because:
    // - In our code that mitigate Chrome synthetic scrolling, that code will look at whether "scrollHeight" value is latest or not.
    // - That code only run on "scroll" event.
    // - That means, on every "scroll" event, if the "scrollHeight" value is not latest, we will skip modifying the stickiness.
    // - That means, if the user "focus" to an element that cause the scroll view to scroll to the bottom, the user agent will fire "scroll" event.
    //   Since the "scrollHeight" is not latest value, this "scroll" event will be ignored and stickiness will not be modified.
    // - That means, if the user "focus" to a newly added element that is at the end of the scroll view, the "scroll to bottom" button will continue to show.
    //
    // Repro in Chrome:
    // 1. Fill up a scroll view
    // 2. Scroll up, the "scroll to bottom" button should show up
    // 3. Click "Add a button"
    // 4. Click on the scroll view (to pseudo-focus on it)
    // 5. Press TAB, the scroll view will be at the bottom
    //
    // Expect:
    // - The "scroll to bottom" button should be gone.
    if (target) {
      var handleFocus = function handleFocus() {
        return setScrollHeight(target.scrollHeight);
      };

      target.addEventListener('focus', handleFocus, {
        capture: true,
        passive: true
      });
      return function () {
        return target.removeEventListener('focus', handleFocus);
      };
    }
  }, [target]);
  return /*#__PURE__*/_react.default.createElement(_InternalContext.default.Provider, {
    value: internalContext
  }, /*#__PURE__*/_react.default.createElement(_FunctionContext.default.Provider, {
    value: functionContext
  }, /*#__PURE__*/_react.default.createElement(_StateContext.default.Provider, {
    value: stateContext
  }, children, target && /*#__PURE__*/_react.default.createElement(_EventSpy.default, {
    debounce: debounce,
    name: "scroll",
    onEvent: handleScroll,
    target: target
  }), target && scrollTop !== null && /*#__PURE__*/_react.default.createElement(_SpineTo.default, {
    name: "scrollTop",
    onEnd: handleScrollEnd,
    target: target,
    value: scrollTop
  }))));
};

Composer.defaultProps = {
  checkInterval: 100,
  children: undefined,
  debounce: 17,
  mode: undefined
};
Composer.propTypes = {
  checkInterval: _propTypes.default.number,
  children: _propTypes.default.any,
  debounce: _propTypes.default.number,
  mode: _propTypes.default.oneOf(['bottom', 'top'])
};
var _default = Composer;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9TY3JvbGxUb0JvdHRvbS9Db21wb3Nlci5qcyJdLCJuYW1lcyI6WyJNSU5fQ0hFQ0tfSU5URVJWQUwiLCJNT0RFX0JPVFRPTSIsIk1PREVfVE9QIiwiTkVBUl9FTkRfVEhSRVNIT0xEIiwiU0NST0xMX0RFQ0lTSU9OX0RVUkFUSU9OIiwic2V0SW1tZWRpYXRlSW50ZXJ2YWwiLCJmbiIsIm1zIiwic2V0SW50ZXJ2YWwiLCJjb21wdXRlVmlld1N0YXRlIiwibW9kZSIsInRhcmdldCIsIm9mZnNldEhlaWdodCIsInNjcm9sbEhlaWdodCIsInNjcm9sbFRvcCIsImF0Qm90dG9tIiwiYXRUb3AiLCJhdEVuZCIsImF0U3RhcnQiLCJpc0VuZCIsIkNvbXBvc2VyIiwiY2hlY2tJbnRlcnZhbCIsImNoaWxkcmVuIiwiZGVib3VuY2UiLCJpZ25vcmVTY3JvbGxFdmVudEJlZm9yZVJlZiIsInNldFNjcm9sbFRvcCIsInNldFRhcmdldCIsInNldE9mZnNldEhlaWdodCIsInNldFNjcm9sbEhlaWdodCIsImFuaW1hdGluZyIsInNldEFuaW1hdGluZyIsInNldEF0Qm90dG9tIiwic2V0QXRFbmQiLCJzZXRBdFRvcCIsInNldEF0U3RhcnQiLCJzdGlja3kiLCJzZXRTdGlja3kiLCJzY3JvbGxQb3NpdGlvbk9ic2VydmVyc1JlZiIsIm9ic2VydmVTY3JvbGxQb3NpdGlvbiIsImN1cnJlbnQiLCJwdXNoIiwic2Nyb2xsUG9zaXRpb25PYnNlcnZlcnMiLCJpbmRleCIsImluZGV4T2YiLCJzcGxpY2UiLCJoYW5kbGVTY3JvbGxFbmQiLCJEYXRlIiwibm93Iiwic2Nyb2xsVG8iLCJiZWhhdmlvciIsImNvbnNvbGUiLCJ3YXJuIiwic2Nyb2xsVG9Cb3R0b20iLCJzY3JvbGxUb1RvcCIsInNjcm9sbFRvRW5kIiwib3B0aW9ucyIsInNjcm9sbFRvU3RhcnQiLCJzdGlja3lCdXROb3RBdEVuZFNpbmNlIiwidGltZW91dCIsIk1hdGgiLCJtYXgiLCJjbGVhckludGVydmFsIiwiaGFuZGxlU2Nyb2xsIiwidGltZVN0YW1wTG93IiwibmV4dE9mZnNldEhlaWdodCIsIm5leHRTY3JvbGxIZWlnaHQiLCJvZmZzZXRIZWlnaHRDaGFuZ2VkIiwic2Nyb2xsSGVpZ2h0Q2hhbmdlZCIsImFjdHVhbFNjcm9sbFRvcCIsImZvckVhY2giLCJvYnNlcnZlciIsImludGVybmFsQ29udGV4dCIsImFuaW1hdGluZ1RvRW5kIiwic3RhdGVDb250ZXh0IiwiZnVuY3Rpb25Db250ZXh0IiwiaGFuZGxlRm9jdXMiLCJhZGRFdmVudExpc3RlbmVyIiwiY2FwdHVyZSIsInBhc3NpdmUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZGVmYXVsdFByb3BzIiwidW5kZWZpbmVkIiwicHJvcFR5cGVzIiwiUHJvcFR5cGVzIiwibnVtYmVyIiwiYW55Iiwib25lT2YiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBLElBQU1BLGtCQUFrQixHQUFHLEVBQTNCLEMsQ0FBK0I7O0FBQy9CLElBQU1DLFdBQVcsR0FBRyxRQUFwQjtBQUNBLElBQU1DLFFBQVEsR0FBRyxLQUFqQjtBQUNBLElBQU1DLGtCQUFrQixHQUFHLENBQTNCO0FBQ0EsSUFBTUMsd0JBQXdCLEdBQUcsRUFBakMsQyxDQUFxQzs7QUFFckMsU0FBU0Msb0JBQVQsQ0FBOEJDLEVBQTlCLEVBQWtDQyxFQUFsQyxFQUFzQztBQUNwQ0QsRUFBQUEsRUFBRTtBQUVGLFNBQU9FLFdBQVcsQ0FBQ0YsRUFBRCxFQUFLQyxFQUFMLENBQWxCO0FBQ0Q7O0FBRUQsU0FBU0UsZ0JBQVQsT0FBdUY7QUFBQSxNQUEzREMsSUFBMkQsUUFBM0RBLElBQTJEO0FBQUEseUJBQXJEQyxNQUFxRDtBQUFBLE1BQTNDQyxZQUEyQyxlQUEzQ0EsWUFBMkM7QUFBQSxNQUE3QkMsWUFBNkIsZUFBN0JBLFlBQTZCO0FBQUEsTUFBZkMsU0FBZSxlQUFmQSxTQUFlO0FBQ3JGLE1B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QyxRQUFuQztBQUE0QyxJQUFBLE9BQU8sRUFBRXVDLFlBQXJEO0FBQW1FLElBQUEsTUFBTSxFQUFFbkQ7QUFBM0UsSUFGYixFQUdHQSxNQUFNLElBQUlHLFNBQVMsS0FBSyxJQUF4QixpQkFDQyw2QkFBQyxnQkFBRDtBQUFTLElBQUEsSUFBSSxFQUFDLFdBQWQ7QUFBMEIsSUFBQSxLQUFLLEVBQUUrQixlQUFqQztBQUFrRCxJQUFBLE1BQU0sRUFBRWxDLE1BQTFEO0FBQWtFLElBQUEsS0FBSyxFQUFFRztBQUF6RSxJQUpKLENBREYsQ0FERixDQURGO0FBYUQsQ0ExU0Q7O0FBNFNBTSxRQUFRLENBQUM0RCxZQUFULEdBQXdCO0FBQ3RCM0QsRUFBQUEsYUFBYSxFQUFFLEdBRE87QUFFdEJDLEVBQUFBLFFBQVEsRUFBRTJELFNBRlk7QUFHdEIxRCxFQUFBQSxRQUFRLEVBQUUsRUFIWTtBQUl0QmIsRUFBQUEsSUFBSSxFQUFFdUU7QUFKZ0IsQ0FBeEI7QUFPQTdELFFBQVEsQ0FBQzhELFNBQVQsR0FBcUI7QUFDbkI3RCxFQUFBQSxhQUFhLEVBQUU4RCxtQkFBVUMsTUFETjtBQUVuQjlELEVBQUFBLFFBQVEsRUFBRTZELG1CQUFVRSxHQUZEO0FBR25COUQsRUFBQUEsUUFBUSxFQUFFNEQsbUJBQVVDLE1BSEQ7QUFJbkIxRSxFQUFBQSxJQUFJLEVBQUV5RSxtQkFBVUcsS0FBVixDQUFnQixDQUFDLFFBQUQsRUFBVyxLQUFYLENBQWhCO0FBSmEsQ0FBckI7ZUFPZWxFLFEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IFJlYWN0LCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZU1lbW8sIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBFdmVudFNweSBmcm9tICcuLi9FdmVudFNweSc7XG5pbXBvcnQgRnVuY3Rpb25Db250ZXh0IGZyb20gJy4vRnVuY3Rpb25Db250ZXh0JztcbmltcG9ydCBJbnRlcm5hbENvbnRleHQgZnJvbSAnLi9JbnRlcm5hbENvbnRleHQnO1xuaW1wb3J0IFNwaW5lVG8gZnJvbSAnLi4vU3BpbmVUbyc7XG5pbXBvcnQgU3RhdGVDb250ZXh0IGZyb20gJy4vU3RhdGVDb250ZXh0JztcblxuY29uc3QgTUlOX0NIRUNLX0lOVEVSVkFMID0gMTc7IC8vIDEgZnJhbWVcbmNvbnN0IE1PREVfQk9UVE9NID0gJ2JvdHRvbSc7XG5jb25zdCBNT0RFX1RPUCA9ICd0b3AnO1xuY29uc3QgTkVBUl9FTkRfVEhSRVNIT0xEID0gMTtcbmNvbnN0IFNDUk9MTF9ERUNJU0lPTl9EVVJBVElPTiA9IDM0OyAvLyAyIGZyYW1lc1xuXG5mdW5jdGlvbiBzZXRJbW1lZGlhdGVJbnRlcnZhbChmbiwgbXMpIHtcbiAgZm4oKTtcblxuICByZXR1cm4gc2V0SW50ZXJ2YWwoZm4sIG1zKTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZVZpZXdTdGF0ZSh7IG1vZGUsIHRhcmdldDogeyBvZmZzZXRIZWlnaHQsIHNjcm9sbEhlaWdodCwgc2Nyb2xsVG9wIH0gfSkge1xuICBjb25zdCBhdEJvdHRvbSA9IHNjcm9sbEhlaWdodCAtIHNjcm9sbFRvcCAtIG9mZnNldEhlaWdodCA8IE5FQVJfRU5EX1RIUkVTSE9MRDtcbiAgY29uc3QgYXRUb3AgPSBzY3JvbGxUb3AgPCBORUFSX0VORF9USFJFU0hPTEQ7XG5cbiAgY29uc3QgYXRFbmQgPSBtb2RlID09PSBNT0RFX1RPUCA/IGF0VG9wIDogYXRCb3R0b207XG4gIGNvbnN0IGF0U3RhcnQgPSBtb2RlICE9PSBNT0RFX1RPUCA/IGF0VG9wIDogYXRCb3R0b207XG5cbiAgcmV0dXJuIHtcbiAgICBhdEJvdHRvbSxcbiAgICBhdEVuZCxcbiAgICBhdFN0YXJ0LFxuICAgIGF0VG9wXG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzRW5kKHNjcm9sbFRvcCwgbW9kZSkge1xuICByZXR1cm4gKG1vZGUgPT09IE1PREVfVE9QICYmIHNjcm9sbFRvcCA9PT0gMCkgfHwgKG1vZGUgPT09IE1PREVfQk9UVE9NICYmIHNjcm9sbFRvcCA9PT0gJzEwMCUnKTtcbn1cblxuY29uc3QgQ29tcG9zZXIgPSAoeyBjaGVja0ludGVydmFsLCBjaGlsZHJlbiwgZGVib3VuY2UsIG1vZGUgfSkgPT4ge1xuICBtb2RlID0gbW9kZSA9PT0gTU9ERV9UT1AgPyBNT0RFX1RPUCA6IE1PREVfQk9UVE9NO1xuXG4gIGNvbnN0IGlnbm9yZVNjcm9sbEV2ZW50QmVmb3JlUmVmID0gdXNlUmVmKDApO1xuICBjb25zdCBbc2Nyb2xsVG9wLCBzZXRTY3JvbGxUb3BdID0gdXNlU3RhdGUobW9kZSA9PT0gTU9ERV9UT1AgPyAwIDogJzEwMCUnKTtcbiAgY29uc3QgW3RhcmdldCwgc2V0VGFyZ2V0XSA9IHVzZVN0YXRlKG51bGwpO1xuXG4gIC8vIEludGVybmFsIGNvbnRleHRcbiAgY29uc3QgW29mZnNldEhlaWdodCwgc2V0T2Zmc2V0SGVpZ2h0XSA9IHVzZVN0YXRlKDApO1xuICBjb25zdCBbc2Nyb2xsSGVpZ2h0LCBzZXRTY3JvbGxIZWlnaHRdID0gdXNlU3RhdGUoMCk7XG5cbiAgLy8gU3RhdGUgY29udGV4dFxuICBjb25zdCBbYW5pbWF0aW5nLCBzZXRBbmltYXRpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbYXRCb3R0b20sIHNldEF0Qm90dG9tXSA9IHVzZVN0YXRlKHRydWUpO1xuICBjb25zdCBbYXRFbmQsIHNldEF0RW5kXSA9IHVzZVN0YXRlKHRydWUpO1xuICBjb25zdCBbYXRUb3AsIHNldEF0VG9wXSA9IHVzZVN0YXRlKHRydWUpO1xuICBjb25zdCBbYXRTdGFydCwgc2V0QXRTdGFydF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtzdGlja3ksIHNldFN0aWNreV0gPSB1c2VTdGF0ZSh0cnVlKTtcblxuICAvLyBIaWdoLXJhdGUgc3RhdGUgY29udGV4dFxuICBjb25zdCBzY3JvbGxQb3NpdGlvbk9ic2VydmVyc1JlZiA9IHVzZVJlZihbXSk7XG4gIGNvbnN0IG9ic2VydmVTY3JvbGxQb3NpdGlvbiA9IHVzZUNhbGxiYWNrKFxuICAgIGZuID0+IHtcbiAgICAgIHNjcm9sbFBvc2l0aW9uT2JzZXJ2ZXJzUmVmLmN1cnJlbnQucHVzaChmbik7XG4gICAgICB0YXJnZXQgJiYgZm4oeyBzY3JvbGxUb3A6IHRhcmdldC5zY3JvbGxUb3AgfSk7XG5cbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgY3VycmVudDogc2Nyb2xsUG9zaXRpb25PYnNlcnZlcnMgfSA9IHNjcm9sbFBvc2l0aW9uT2JzZXJ2ZXJzUmVmO1xuICAgICAgICBjb25zdCBpbmRleCA9IHNjcm9sbFBvc2l0aW9uT2JzZXJ2ZXJzLmluZGV4T2YoZm4pO1xuXG4gICAgICAgIH5pbmRleCAmJiBzY3JvbGxQb3NpdGlvbk9ic2VydmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfTtcbiAgICB9LFxuICAgIFtzY3JvbGxQb3NpdGlvbk9ic2VydmVyc1JlZiwgdGFyZ2V0XVxuICApO1xuXG4gIGNvbnN0IGhhbmRsZVNjcm9sbEVuZCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZ25vcmVTY3JvbGxFdmVudEJlZm9yZVJlZi5jdXJyZW50ID0gRGF0ZS5ub3coKTtcbiAgICBzZXRBbmltYXRpbmcoZmFsc2UpO1xuICAgIHNldFNjcm9sbFRvcChudWxsKTtcbiAgfSwgW2lnbm9yZVNjcm9sbEV2ZW50QmVmb3JlUmVmLCBzZXRBbmltYXRpbmcsIHNldFNjcm9sbFRvcF0pO1xuXG4gIC8vIEZ1bmN0aW9uIGNvbnRleHRcbiAgY29uc3Qgc2Nyb2xsVG8gPSB1c2VDYWxsYmFjayhcbiAgICAoc2Nyb2xsVG9wLCB7IGJlaGF2aW9yIH0gPSB7fSkgPT4ge1xuICAgICAgaWYgKGJlaGF2aW9yID09PSAnYXV0bycpIHtcbiAgICAgICAgLy8gU3RvcCBhbnkgZXhpc3RpbmcgYW5pbWF0aW9uXG4gICAgICAgIGhhbmRsZVNjcm9sbEVuZCgpO1xuXG4gICAgICAgIC8vIEp1bXAgdG8gdGhlIHNjcm9sbCBwb3NpdGlvblxuICAgICAgICB0YXJnZXQuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wID09PSAnMTAwJScgPyB0YXJnZXQuc2Nyb2xsSGVpZ2h0IC0gdGFyZ2V0Lm9mZnNldEhlaWdodCA6IHNjcm9sbFRvcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJlaGF2aW9yICE9PSAnc21vb3RoJyAmJlxuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICdyZWFjdC1zY3JvbGwtdG8tYm90dG9tOiBQbGVhc2Ugc2V0IFwiYmVoYXZpb3JcIiB3aGVuIGNhbGxpbmcgXCJzY3JvbGxUb1wiLiBJbiBmdXR1cmUgdmVyc2lvbnMsIHRoZSBkZWZhdWx0IGJlaGF2aW9yIHdpbGwgYmUgY2hhbmdlZCBmcm9tIHNtb290aCBzY3JvbGxpbmcgdG8gZGlzY3JldGUgc2Nyb2xsaW5nIHRvIGFsaWduIHdpdGggSFRNTCBTdGFuZGFyZC4nXG4gICAgICAgICAgKTtcblxuICAgICAgICBzZXRBbmltYXRpbmcodHJ1ZSk7XG4gICAgICAgIHNldFNjcm9sbFRvcChzY3JvbGxUb3ApO1xuICAgICAgfVxuICAgIH0sXG4gICAgW2hhbmRsZVNjcm9sbEVuZCwgc2V0QW5pbWF0aW5nLCBzZXRTY3JvbGxUb3AsIHRhcmdldF1cbiAgKTtcblxuICBjb25zdCBzY3JvbGxUb0JvdHRvbSA9IHVzZUNhbGxiYWNrKFxuICAgICh7IGJlaGF2aW9yIH0gPSB7fSkgPT4ge1xuICAgICAgYmVoYXZpb3IgIT09ICdzbW9vdGgnICYmXG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAncmVhY3Qtc2Nyb2xsLXRvLWJvdHRvbTogUGxlYXNlIHNldCBcImJlaGF2aW9yXCIgd2hlbiBjYWxsaW5nIFwic2Nyb2xsVG9Cb3R0b21cIi4gSW4gZnV0dXJlIHZlcnNpb25zLCB0aGUgZGVmYXVsdCBiZWhhdmlvciB3aWxsIGJlIGNoYW5nZWQgZnJvbSBzbW9vdGggc2Nyb2xsaW5nIHRvIGRpc2NyZXRlIHNjcm9sbGluZyB0byBhbGlnbiB3aXRoIEhUTUwgU3RhbmRhcmQuJ1xuICAgICAgICApO1xuXG4gICAgICBzY3JvbGxUbygnMTAwJScsIHsgYmVoYXZpb3I6IGJlaGF2aW9yIHx8ICdzbW9vdGgnIH0pO1xuICAgIH0sXG4gICAgW3Njcm9sbFRvXVxuICApO1xuXG4gIGNvbnN0IHNjcm9sbFRvVG9wID0gdXNlQ2FsbGJhY2soXG4gICAgKHsgYmVoYXZpb3IgfSA9IHt9KSA9PiB7XG4gICAgICBiZWhhdmlvciAhPT0gJ3Ntb290aCcgJiZcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICdyZWFjdC1zY3JvbGwtdG8tYm90dG9tOiBQbGVhc2Ugc2V0IFwiYmVoYXZpb3JcIiB3aGVuIGNhbGxpbmcgXCJzY3JvbGxUb1RvcFwiLiBJbiBmdXR1cmUgdmVyc2lvbnMsIHRoZSBkZWZhdWx0IGJlaGF2aW9yIHdpbGwgYmUgY2hhbmdlZCBmcm9tIHNtb290aCBzY3JvbGxpbmcgdG8gZGlzY3JldGUgc2Nyb2xsaW5nIHRvIGFsaWduIHdpdGggSFRNTCBTdGFuZGFyZC4nXG4gICAgICAgICk7XG5cbiAgICAgIHNjcm9sbFRvKDAsIHsgYmVoYXZpb3I6IGJlaGF2aW9yIHx8ICdzbW9vdGgnIH0pO1xuICAgIH0sXG4gICAgW3Njcm9sbFRvXVxuICApO1xuXG4gIGNvbnN0IHNjcm9sbFRvRW5kID0gdXNlQ2FsbGJhY2soXG4gICAgKHsgYmVoYXZpb3IgfSA9IHt9KSA9PiB7XG4gICAgICBiZWhhdmlvciAhPT0gJ3Ntb290aCcgJiZcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICdyZWFjdC1zY3JvbGwtdG8tYm90dG9tOiBQbGVhc2Ugc2V0IFwiYmVoYXZpb3JcIiB3aGVuIGNhbGxpbmcgXCJzY3JvbGxUb0VuZFwiLiBJbiBmdXR1cmUgdmVyc2lvbnMsIHRoZSBkZWZhdWx0IGJlaGF2aW9yIHdpbGwgYmUgY2hhbmdlZCBmcm9tIHNtb290aCBzY3JvbGxpbmcgdG8gZGlzY3JldGUgc2Nyb2xsaW5nIHRvIGFsaWduIHdpdGggSFRNTCBTdGFuZGFyZC4nXG4gICAgICAgICk7XG5cbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7IGJlaGF2aW9yOiBiZWhhdmlvciB8fCAnc21vb3RoJyB9O1xuXG4gICAgICBtb2RlID09PSBNT0RFX1RPUCA/IHNjcm9sbFRvVG9wKG9wdGlvbnMpIDogc2Nyb2xsVG9Cb3R0b20ob3B0aW9ucyk7XG4gICAgfSxcbiAgICBbbW9kZSwgc2Nyb2xsVG9Cb3R0b20sIHNjcm9sbFRvVG9wXVxuICApO1xuXG4gIGNvbnN0IHNjcm9sbFRvU3RhcnQgPSB1c2VDYWxsYmFjayhcbiAgICAoeyBiZWhhdmlvciB9ID0ge30pID0+IHtcbiAgICAgIGJlaGF2aW9yICE9PSAnc21vb3RoJyAmJlxuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgJ3JlYWN0LXNjcm9sbC10by1ib3R0b206IFBsZWFzZSBzZXQgXCJiZWhhdmlvclwiIHdoZW4gY2FsbGluZyBcInNjcm9sbFRvU3RhcnRcIi4gSW4gZnV0dXJlIHZlcnNpb25zLCB0aGUgZGVmYXVsdCBiZWhhdmlvciB3aWxsIGJlIGNoYW5nZWQgZnJvbSBzbW9vdGggc2Nyb2xsaW5nIHRvIGRpc2NyZXRlIHNjcm9sbGluZyB0byBhbGlnbiB3aXRoIEhUTUwgU3RhbmRhcmQuJ1xuICAgICAgICApO1xuXG4gICAgICBjb25zdCBvcHRpb25zID0geyBiZWhhdmlvcjogYmVoYXZpb3IgfHwgJ3Ntb290aCcgfTtcblxuICAgICAgbW9kZSA9PT0gTU9ERV9UT1AgPyBzY3JvbGxUb0JvdHRvbShvcHRpb25zKSA6IHNjcm9sbFRvVG9wKG9wdGlvbnMpO1xuICAgIH0sXG4gICAgW21vZGUsIHNjcm9sbFRvQm90dG9tLCBzY3JvbGxUb1RvcF1cbiAgKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChzdGlja3kpIHtcbiAgICAgIGxldCBzdGlja3lCdXROb3RBdEVuZFNpbmNlID0gZmFsc2U7XG5cbiAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRJbW1lZGlhdGVJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIGlmIChzdGlja3kgJiYgdGFyZ2V0ICYmICFjb21wdXRlVmlld1N0YXRlKHsgbW9kZSwgdGFyZ2V0IH0pLmF0RW5kKSB7XG4gICAgICAgICAgaWYgKCFzdGlja3lCdXROb3RBdEVuZFNpbmNlKSB7XG4gICAgICAgICAgICBzdGlja3lCdXROb3RBdEVuZFNpbmNlID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKERhdGUubm93KCkgLSBzdGlja3lCdXROb3RBdEVuZFNpbmNlID4gU0NST0xMX0RFQ0lTSU9OX0RVUkFUSU9OKSB7XG4gICAgICAgICAgICAvLyBRdWlya3M6IEluIEZpcmVmb3gsIGFmdGVyIHVzZXIgc2Nyb2xsIGRvd24sIEZpcmVmb3ggZG8gdHdvIHRoaW5nczpcbiAgICAgICAgICAgIC8vICAgICAgICAgMS4gU2V0IHRvIGEgbmV3IFwic2Nyb2xsVG9wXCJcbiAgICAgICAgICAgIC8vICAgICAgICAgMi4gRmlyZSBcInNjcm9sbFwiIGV2ZW50XG4gICAgICAgICAgICAvLyAgICAgICAgIEZvciB3aGF0IHdlIG9ic2VydmVkLCAjMSBpcyBmaXJlZCBhYm91dCAyMG1zIGJlZm9yZSAjMi4gVGhlcmUgaXMgYSBjaGFuY2UgdGhhdCB0aGlzIHN0aWNreUNoZWNrVGltZW91dCBpcyBiZWluZyBzY2hlZHVsZWQgYmV0d2VlbiAxIGFuZCAyLlxuICAgICAgICAgICAgLy8gICAgICAgICBUaGF0IG1lYW5zLCBpZiB3ZSBqdXN0IGxvb2sgYXQgIzEgdG8gZGVjaWRlIGlmIHdlIHNob3VsZCBzY3JvbGwsIHdlIHdpbGwgYWx3YXlzIHNjcm9sbCwgaW4gb3Bwb3NlIHRvIHRoZSB1c2VyJ3MgaW50ZW50aW9uLlxuICAgICAgICAgICAgLy8gUmVwcm86IE9wZW4gRmlyZWZveCwgc2V0IGNoZWNrSW50ZXJ2YWwgdG8gYSBsb3dlciBudW1iZXIsIGFuZCB0cnkgdG8gc2Nyb2xsIGJ5IGRyYWdnaW5nIHRoZSBzY3JvbGwgaGFuZGxlci4gSXQgd2lsbCBqdW1wIGJhY2suXG5cbiAgICAgICAgICAgICFhbmltYXRpbmcgJiYgc2Nyb2xsVG9FbmQoeyBiZWhhdmlvcjogJ3Ntb290aCcgfSk7XG4gICAgICAgICAgICBzdGlja3lCdXROb3RBdEVuZFNpbmNlID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0aWNreUJ1dE5vdEF0RW5kU2luY2UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSwgTWF0aC5tYXgoTUlOX0NIRUNLX0lOVEVSVkFMLCBjaGVja0ludGVydmFsKSB8fCBNSU5fQ0hFQ0tfSU5URVJWQUwpO1xuXG4gICAgICByZXR1cm4gKCkgPT4gY2xlYXJJbnRlcnZhbCh0aW1lb3V0KTtcbiAgICB9XG4gIH0sIFthbmltYXRpbmcsIGNoZWNrSW50ZXJ2YWwsIG1vZGUsIHNjcm9sbFRvRW5kLCBzdGlja3ksIHRhcmdldF0pO1xuXG4gIGNvbnN0IGhhbmRsZVNjcm9sbCA9IHVzZUNhbGxiYWNrKFxuICAgICh7IHRpbWVTdGFtcExvdyB9KSA9PiB7XG4gICAgICAvLyBDdXJyZW50bHksIHRoZXJlIGFyZSBubyByZWxpYWJsZSB3YXkgdG8gY2hlY2sgaWYgdGhlIFwic2Nyb2xsXCIgZXZlbnQgaXMgdHJpZ2dlciBkdWUgdG9cbiAgICAgIC8vIHVzZXIgZ2VzdHVyZSwgcHJvZ3JhbW1hdGljIHNjcm9sbGluZywgb3IgQ2hyb21lLXN5bnRoZXNpemVkIFwic2Nyb2xsXCIgZXZlbnQgdG8gY29tcGVuc2F0ZSBzaXplIGNoYW5nZS5cbiAgICAgIC8vIFRodXMsIHdlIHVzZSBvdXIgYmVzdC1lZmZvcnQgdG8gZ3Vlc3MgaWYgaXQgaXMgdHJpZ2dlcmVkIGJ5IHVzZXIgZ2VzdHVyZSwgYW5kIGRpc2FibGUgc3RpY2t5IGlmIGl0IGlzIGhlYWRpbmcgdG93YXJkcyB0aGUgc3RhcnQgZGlyZWN0aW9uLlxuXG4gICAgICBpZiAodGltZVN0YW1wTG93IDw9IGlnbm9yZVNjcm9sbEV2ZW50QmVmb3JlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgLy8gU2luY2Ugd2UgZGVib3VuY2UgXCJzY3JvbGxcIiBldmVudCwgdGhpcyBoYW5kbGVyIG1pZ2h0IGJlIGNhbGxlZCBhZnRlciBzcGluZVRvLm9uRW5kIChhLmsuYS4gYXJ0aWZpY2lhbCBzY3JvbGxpbmcpLlxuICAgICAgICAvLyBXZSBzaG91bGQgaWdub3JlIGRlYm91bmNlZCBldmVudCBmaXJlZCBhZnRlciBzY3JvbGxFbmQsIGJlY2F1c2Ugd2l0aG91dCBza2lwcGluZyB0aGVtLCB0aGUgdXNlckluaXRpYXRlZFNjcm9sbCBjYWxjdWxhdGVkIGJlbG93IHdpbGwgbm90IGJlIGFjY3VyYXRlLlxuICAgICAgICAvLyBUaHVzLCBvbiBhIGZhc3QgbWFjaGluZSwgYWRkaW5nIGVsZW1lbnRzIHN1cGVyIGZhc3Qgd2lsbCBsb3NlIHRoZSBcInN0aWNraW5lc3NcIi5cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgY29uc3QgeyBhdEJvdHRvbSwgYXRFbmQsIGF0U3RhcnQsIGF0VG9wIH0gPSBjb21wdXRlVmlld1N0YXRlKHsgbW9kZSwgdGFyZ2V0IH0pO1xuXG4gICAgICAgIHNldEF0Qm90dG9tKGF0Qm90dG9tKTtcbiAgICAgICAgc2V0QXRFbmQoYXRFbmQpO1xuICAgICAgICBzZXRBdFN0YXJ0KGF0U3RhcnQpO1xuICAgICAgICBzZXRBdFRvcChhdFRvcCk7XG5cbiAgICAgICAgLy8gQ2hyb21lIHdpbGwgZW1pdCBcInN5bnRoZXRpY1wiIHNjcm9sbCBldmVudCBpZiB0aGUgY29udGFpbmVyIGlzIHJlc2l6ZWQgb3IgYW4gZWxlbWVudCBpcyBhZGRlZFxuICAgICAgICAvLyBXZSBuZWVkIHRvIGlnbm9yZSB0aGVzZSBcInN5bnRoZXRpY1wiIGV2ZW50c1xuICAgICAgICAvLyBSZXBybzogSW4gcGxheWdyb3VuZCwgcHJlc3MgNC0xLTUtMS0xIChzbWFsbCwgYWRkIG9uZSwgbm9ybWFsLCBhZGQgb25lLCBhZGQgb25lKVxuICAgICAgICAvLyAgICAgICAgTm9tYXR0ZXIgaG93IGZhc3Qgb3Igc2xvdyB0aGUgc2VxdWVuY2UgaXMgYmVpbmcgcHJlc3NlZCwgaXQgc2hvdWxkIHN0aWxsIHN0aWNrIHRvIHRoZSBib3R0b21cbiAgICAgICAgY29uc3QgeyBvZmZzZXRIZWlnaHQ6IG5leHRPZmZzZXRIZWlnaHQsIHNjcm9sbEhlaWdodDogbmV4dFNjcm9sbEhlaWdodCB9ID0gdGFyZ2V0O1xuICAgICAgICBjb25zdCBvZmZzZXRIZWlnaHRDaGFuZ2VkID0gbmV4dE9mZnNldEhlaWdodCAhPT0gb2Zmc2V0SGVpZ2h0O1xuICAgICAgICBjb25zdCBzY3JvbGxIZWlnaHRDaGFuZ2VkID0gbmV4dFNjcm9sbEhlaWdodCAhPT0gc2Nyb2xsSGVpZ2h0O1xuXG4gICAgICAgIG9mZnNldEhlaWdodENoYW5nZWQgJiYgc2V0T2Zmc2V0SGVpZ2h0KG5leHRPZmZzZXRIZWlnaHQpO1xuICAgICAgICBzY3JvbGxIZWlnaHRDaGFuZ2VkICYmIHNldFNjcm9sbEhlaWdodChuZXh0U2Nyb2xsSGVpZ2h0KTtcblxuICAgICAgICAvLyBTdGlja3kgbWVhbnM6XG4gICAgICAgIC8vIC0gSWYgaXQgaXMgc2Nyb2xsZWQgcHJvZ3JhbWF0aWNhbGx5LCB3ZSBhcmUgc3RpbGwgaW4gc3RpY2t5IG1vZGVcbiAgICAgICAgLy8gLSBJZiBpdCBpcyBzY3JvbGxlZCBieSB0aGUgdXNlciwgdGhlbiBzdGlja3kgbWVhbnMgaWYgd2UgYXJlIGF0IHRoZSBlbmRcblxuICAgICAgICAvLyBPbmx5IHVwZGF0ZSBzdGlja2luZXNzIGlmIHRoZSBzY3JvbGwgZXZlbnQgaXMgbm90IGR1ZSB0byBzeW50aGV0aWMgc2Nyb2xsIGRvbmUgYnkgQ2hyb21lXG4gICAgICAgICFvZmZzZXRIZWlnaHRDaGFuZ2VkICYmXG4gICAgICAgICAgIXNjcm9sbEhlaWdodENoYW5nZWQgJiZcbiAgICAgICAgICBzZXRTdGlja3koXG4gICAgICAgICAgICAvLyBXZSBhcmUgc3RpY2t5IGlmIHdlIGFyZSBhbmltYXRpbmcgdG8gdGhlIGVuZCwgb3Igd2UgYXJlIGFscmVhZHkgYXQgdGhlIGVuZC5cbiAgICAgICAgICAgIC8vIFdlIGNhbiBiZSBcImFuaW1hdGluZyBidXQgbm90IHN0aWNreVwiIGJ5IGNhbGxpbmcgXCJzY3JvbGxUbygxMDApXCIgd2hlcmUgdGhlIGNvbnRhaW5lciBzY3JvbGxIZWlnaHQgaXMgMjAwcHguXG4gICAgICAgICAgICAoYW5pbWF0aW5nICYmIGlzRW5kKHNjcm9sbFRvcCwgbW9kZSkpIHx8IGF0RW5kXG4gICAgICAgICAgKTtcblxuICAgICAgICAvLyBJZiBubyBzY3JvbGxUb3AgaXMgc2V0IChub3QgaW4gcHJvZ3JhbW1hdGljIHNjcm9sbGluZyBtb2RlKSwgd2Ugc2hvdWxkIHNldCBcImFuaW1hdGluZ1wiIHRvIGZhbHNlXG4gICAgICAgIC8vIFwiYW5pbWF0aW5nXCIgaXMgdXNlZCB0byBjYWxjdWxhdGUgdGhlIFwic3RpY2t5XCIgcHJvcGVydHlcbiAgICAgICAgc2Nyb2xsVG9wID09PSBudWxsICYmIHNldEFuaW1hdGluZyhmYWxzZSk7XG5cbiAgICAgICAgY29uc3QgeyBzY3JvbGxUb3A6IGFjdHVhbFNjcm9sbFRvcCB9ID0gdGFyZ2V0O1xuXG4gICAgICAgIHNjcm9sbFBvc2l0aW9uT2JzZXJ2ZXJzUmVmLmN1cnJlbnQuZm9yRWFjaChvYnNlcnZlciA9PiBvYnNlcnZlcih7IHNjcm9sbFRvcDogYWN0dWFsU2Nyb2xsVG9wIH0pKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtcbiAgICAgIGFuaW1hdGluZyxcbiAgICAgIGlnbm9yZVNjcm9sbEV2ZW50QmVmb3JlUmVmLFxuICAgICAgbW9kZSxcbiAgICAgIG9mZnNldEhlaWdodCxcbiAgICAgIHNjcm9sbEhlaWdodCxcbiAgICAgIHNjcm9sbFBvc2l0aW9uT2JzZXJ2ZXJzUmVmLFxuICAgICAgc2Nyb2xsVG9wLFxuICAgICAgc2V0QW5pbWF0aW5nLFxuICAgICAgc2V0QXRCb3R0b20sXG4gICAgICBzZXRBdEVuZCxcbiAgICAgIHNldEF0U3RhcnQsXG4gICAgICBzZXRBdFRvcCxcbiAgICAgIHNldE9mZnNldEhlaWdodCxcbiAgICAgIHNldFNjcm9sbEhlaWdodCxcbiAgICAgIHNldFN0aWNreSxcbiAgICAgIHRhcmdldFxuICAgIF1cbiAgKTtcblxuICBjb25zdCBpbnRlcm5hbENvbnRleHQgPSB1c2VNZW1vKFxuICAgICgpID0+ICh7XG4gICAgICBvYnNlcnZlU2Nyb2xsUG9zaXRpb24sXG4gICAgICBvZmZzZXRIZWlnaHQsXG4gICAgICBzY3JvbGxIZWlnaHQsXG4gICAgICBzZXRUYXJnZXRcbiAgICB9KSxcbiAgICBbb2JzZXJ2ZVNjcm9sbFBvc2l0aW9uLCBvZmZzZXRIZWlnaHQsIHNjcm9sbEhlaWdodCwgc2V0VGFyZ2V0XVxuICApO1xuXG4gIGNvbnN0IGFuaW1hdGluZ1RvRW5kID0gYW5pbWF0aW5nICYmIGlzRW5kKHNjcm9sbFRvcCwgbW9kZSk7XG5cbiAgY29uc3Qgc3RhdGVDb250ZXh0ID0gdXNlTWVtbyhcbiAgICAoKSA9PiAoe1xuICAgICAgYW5pbWF0aW5nLFxuICAgICAgYW5pbWF0aW5nVG9FbmQsXG4gICAgICBhdEJvdHRvbSxcbiAgICAgIGF0RW5kLFxuICAgICAgYXRTdGFydCxcbiAgICAgIGF0VG9wLFxuICAgICAgbW9kZSxcbiAgICAgIHN0aWNreVxuICAgIH0pLFxuICAgIFthbmltYXRpbmcsIGFuaW1hdGluZ1RvRW5kLCBhdEJvdHRvbSwgYXRFbmQsIGF0U3RhcnQsIGF0VG9wLCBtb2RlLCBzdGlja3ldXG4gICk7XG5cbiAgY29uc3QgZnVuY3Rpb25Db250ZXh0ID0gdXNlTWVtbyhcbiAgICAoKSA9PiAoe1xuICAgICAgc2Nyb2xsVG8sXG4gICAgICBzY3JvbGxUb0JvdHRvbSxcbiAgICAgIHNjcm9sbFRvRW5kLFxuICAgICAgc2Nyb2xsVG9TdGFydCxcbiAgICAgIHNjcm9sbFRvVG9wXG4gICAgfSksXG4gICAgW3Njcm9sbFRvLCBzY3JvbGxUb0JvdHRvbSwgc2Nyb2xsVG9FbmQsIHNjcm9sbFRvU3RhcnQsIHNjcm9sbFRvVG9wXVxuICApO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gV2UgbmVlZCB0byB1cGRhdGUgdGhlIFwic2Nyb2xsSGVpZ2h0XCIgdmFsdWUgdG8gbGF0ZXN0IHdoZW4gdGhlIHVzZXIgZG8gYSBmb2N1cyBpbnNpZGUgdGhlIGJveC5cbiAgICAvL1xuICAgIC8vIFRoaXMgaXMgYmVjYXVzZTpcbiAgICAvLyAtIEluIG91ciBjb2RlIHRoYXQgbWl0aWdhdGUgQ2hyb21lIHN5bnRoZXRpYyBzY3JvbGxpbmcsIHRoYXQgY29kZSB3aWxsIGxvb2sgYXQgd2hldGhlciBcInNjcm9sbEhlaWdodFwiIHZhbHVlIGlzIGxhdGVzdCBvciBub3QuXG4gICAgLy8gLSBUaGF0IGNvZGUgb25seSBydW4gb24gXCJzY3JvbGxcIiBldmVudC5cbiAgICAvLyAtIFRoYXQgbWVhbnMsIG9uIGV2ZXJ5IFwic2Nyb2xsXCIgZXZlbnQsIGlmIHRoZSBcInNjcm9sbEhlaWdodFwiIHZhbHVlIGlzIG5vdCBsYXRlc3QsIHdlIHdpbGwgc2tpcCBtb2RpZnlpbmcgdGhlIHN0aWNraW5lc3MuXG4gICAgLy8gLSBUaGF0IG1lYW5zLCBpZiB0aGUgdXNlciBcImZvY3VzXCIgdG8gYW4gZWxlbWVudCB0aGF0IGNhdXNlIHRoZSBzY3JvbGwgdmlldyB0byBzY3JvbGwgdG8gdGhlIGJvdHRvbSwgdGhlIHVzZXIgYWdlbnQgd2lsbCBmaXJlIFwic2Nyb2xsXCIgZXZlbnQuXG4gICAgLy8gICBTaW5jZSB0aGUgXCJzY3JvbGxIZWlnaHRcIiBpcyBub3QgbGF0ZXN0IHZhbHVlLCB0aGlzIFwic2Nyb2xsXCIgZXZlbnQgd2lsbCBiZSBpZ25vcmVkIGFuZCBzdGlja2luZXNzIHdpbGwgbm90IGJlIG1vZGlmaWVkLlxuICAgIC8vIC0gVGhhdCBtZWFucywgaWYgdGhlIHVzZXIgXCJmb2N1c1wiIHRvIGEgbmV3bHkgYWRkZWQgZWxlbWVudCB0aGF0IGlzIGF0IHRoZSBlbmQgb2YgdGhlIHNjcm9sbCB2aWV3LCB0aGUgXCJzY3JvbGwgdG8gYm90dG9tXCIgYnV0dG9uIHdpbGwgY29udGludWUgdG8gc2hvdy5cbiAgICAvL1xuICAgIC8vIFJlcHJvIGluIENocm9tZTpcbiAgICAvLyAxLiBGaWxsIHVwIGEgc2Nyb2xsIHZpZXdcbiAgICAvLyAyLiBTY3JvbGwgdXAsIHRoZSBcInNjcm9sbCB0byBib3R0b21cIiBidXR0b24gc2hvdWxkIHNob3cgdXBcbiAgICAvLyAzLiBDbGljayBcIkFkZCBhIGJ1dHRvblwiXG4gICAgLy8gNC4gQ2xpY2sgb24gdGhlIHNjcm9sbCB2aWV3ICh0byBwc2V1ZG8tZm9jdXMgb24gaXQpXG4gICAgLy8gNS4gUHJlc3MgVEFCLCB0aGUgc2Nyb2xsIHZpZXcgd2lsbCBiZSBhdCB0aGUgYm90dG9tXG4gICAgLy9cbiAgICAvLyBFeHBlY3Q6XG4gICAgLy8gLSBUaGUgXCJzY3JvbGwgdG8gYm90dG9tXCIgYnV0dG9uIHNob3VsZCBiZSBnb25lLlxuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIGNvbnN0IGhhbmRsZUZvY3VzID0gKCkgPT4gc2V0U2Nyb2xsSGVpZ2h0KHRhcmdldC5zY3JvbGxIZWlnaHQpO1xuXG4gICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBoYW5kbGVGb2N1cywgeyBjYXB0dXJlOiB0cnVlLCBwYXNzaXZlOiB0cnVlIH0pO1xuXG4gICAgICByZXR1cm4gKCkgPT4gdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgaGFuZGxlRm9jdXMpO1xuICAgIH1cbiAgfSwgW3RhcmdldF0pO1xuXG4gIHJldHVybiAoXG4gICAgPEludGVybmFsQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17aW50ZXJuYWxDb250ZXh0fT5cbiAgICAgIDxGdW5jdGlvbkNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2Z1bmN0aW9uQ29udGV4dH0+XG4gICAgICAgIDxTdGF0ZUNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3N0YXRlQ29udGV4dH0+XG4gICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICAgIHt0YXJnZXQgJiYgPEV2ZW50U3B5IGRlYm91bmNlPXtkZWJvdW5jZX0gbmFtZT1cInNjcm9sbFwiIG9uRXZlbnQ9e2hhbmRsZVNjcm9sbH0gdGFyZ2V0PXt0YXJnZXR9IC8+fVxuICAgICAgICAgIHt0YXJnZXQgJiYgc2Nyb2xsVG9wICE9PSBudWxsICYmIChcbiAgICAgICAgICAgIDxTcGluZVRvIG5hbWU9XCJzY3JvbGxUb3BcIiBvbkVuZD17aGFuZGxlU2Nyb2xsRW5kfSB0YXJnZXQ9e3RhcmdldH0gdmFsdWU9e3Njcm9sbFRvcH0gLz5cbiAgICAgICAgICApfVxuICAgICAgICA8L1N0YXRlQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgIDwvRnVuY3Rpb25Db250ZXh0LlByb3ZpZGVyPlxuICAgIDwvSW50ZXJuYWxDb250ZXh0LlByb3ZpZGVyPlxuICApO1xufTtcblxuQ29tcG9zZXIuZGVmYXVsdFByb3BzID0ge1xuICBjaGVja0ludGVydmFsOiAxMDAsXG4gIGNoaWxkcmVuOiB1bmRlZmluZWQsXG4gIGRlYm91bmNlOiAxNyxcbiAgbW9kZTogdW5kZWZpbmVkXG59O1xuXG5Db21wb3Nlci5wcm9wVHlwZXMgPSB7XG4gIGNoZWNrSW50ZXJ2YWw6IFByb3BUeXBlcy5udW1iZXIsXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMuYW55LFxuICBkZWJvdW5jZTogUHJvcFR5cGVzLm51bWJlcixcbiAgbW9kZTogUHJvcFR5cGVzLm9uZU9mKFsnYm90dG9tJywgJ3RvcCddKVxufTtcblxuZXhwb3J0IGRlZmF1bHQgQ29tcG9zZXI7XG4iXX0=